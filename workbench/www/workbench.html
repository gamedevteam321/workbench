{% extends "templates/web.html" %}
{% block title %}Workbench{% endblock %}

{% block head_include %}
<link rel="stylesheet" href="/assets/workbench/css/workbench.bundle.css">
<script src="/assets/workbench/js/db/inline_api.js"></script>
<script src="/assets/workbench/js/editor/blocks_collection.js"></script>
<script>
console.log('HTML template loaded');
</script>
{% endblock %}

{% block page_content %}
<div id="wb-app">
  <aside class="wb-sidebar">
    <div class="wb-topbar">
      <div class="wb-logo">Workbench</div>
      <div class="wb-topbar-actions">
        <button id="wb-new-workspace" class="wb-btn ghost" title="New Workspace">+</button>
        <button id="wb-new-page" class="wb-btn">+ New</button>
      </div>
    </div>
    
    <div class="wb-sidebar-content">
      <div class="wb-section">
        <div class="wb-section-header">
          <span class="wb-section-title">Private</span>
        </div>
        <div class="wb-section-content">
          <div class="wb-new-page-item">
            <span class="wb-new-page-icon">üìÑ</span>
            <span class="wb-new-page-text">New page</span>
          </div>
          <div id="wb-private-pages" class="wb-page-list"></div>
        </div>
      </div>
      
      <div class="wb-section">
        <div class="wb-section-header">
          <span class="wb-section-title">Workspaces</span>
        </div>
        <div class="wb-section-content">
          <div id="wb-workspaces" class="wb-workspace-list"></div>
          <div class="wb-add-workspace-item">
            <span class="wb-add-workspace-icon">+</span>
            <span class="wb-add-workspace-text">Add new</span>
          </div>
        </div>
      </div>
    </div>
    
    <div class="wb-search">
      <input id="wb-search" placeholder="Search pages‚Ä¶" />
    </div>
  </aside>

  <main class="wb-main">
    <div class="wb-page-header">
      <div class="wb-breadcrumbs">
        <button id="wb-back" class="wb-iconbtn" title="Back">‚Üê</button>
        <span id="wb-crumb-title">New page</span>
        <span class="wb-badge">Private</span>
      </div>
      <div class="wb-actions">
        <!-- Theme and delete buttons removed -->
      </div>
    </div>

    <div class="wb-page-title-row">
      <input id="wb-title" class="wb-title" placeholder="Untitled" />
    </div>

    <div id="wb-editor" class="wb-editor" spellcheck="true"></div>
  </main>
</div>

<script>
console.log('Starting Notion-style workbench...');

// Global variables for page and workspace management
let currentWorkspace = null;
let currentPageName = null;

// Helper function to refresh the pages list
function refreshPagesList() {
  if (!currentWorkspace) return;
  
  const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
  
  fetch(`/api/method/workbench.api.get_workspace_pages?workspace=${currentWorkspace}`, {
    method: 'GET',
    headers: {
      'X-Frappe-CSRF-Token': csrfToken || 'token'
    }
  })
  .then(response => response.json())
  .then(data => {
    if (data.message) {
      const pages = data.message;
      const pagesContainer = document.querySelector('.wb-pages-list');
      
      if (pagesContainer) {
        // Clear existing pages
        pagesContainer.innerHTML = '';
        
        // Add each page
        pages.forEach(page => {
          const pageItem = document.createElement('div');
          pageItem.className = 'wb-page-item';
          pageItem.innerHTML = `
            <div class="wb-page-content">
              <div class="wb-page-icon">üìÑ</div>
              <div class="wb-page-info">
                <div class="wb-page-title">${page.title}</div>
                <div class="wb-page-meta">${formatDate(page.last_edited_date)}</div>
              </div>
              <button class="wb-page-menu-btn" title="Page options">‚ãØ</button>
            </div>
          `;
          
          // Add click handler
          pageItem.querySelector('.wb-page-content').addEventListener('click', () => {
            loadPage(page.name);
          });
          
          pagesContainer.appendChild(pageItem);
        });
        
        // Show empty state if no pages
        if (pages.length === 0) {
          pagesContainer.innerHTML = '<div class="wb-empty-pages">No pages yet</div>';
        }
      }
    }
  })
  .catch(error => {
    console.error('Error refreshing pages list:', error);
  });
}

// Helper function to format date
function formatDate(dateString) {
  if (!dateString) return 'Just now';
  
  const date = new Date(dateString);
  const now = new Date();
  const diffMs = now - date;
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMs / 3600000);
  const diffDays = Math.floor(diffMs / 86400000);
  
  if (diffMins < 1) return 'Just now';
  if (diffMins < 60) return `${diffMins}m ago`;
  if (diffHours < 24) return `${diffHours}h ago`;
  if (diffDays < 7) return `${diffDays}d ago`;
  
  return date.toLocaleDateString();
}

// Helper function to create a new empty page
function createNewEmptyPage() {
  // Create a new empty page in the current workspace
  const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
  
  fetch('/api/method/workbench.api.create_page', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Frappe-CSRF-Token': csrfToken || 'token'
    },
    body: JSON.stringify({
      title: 'New Page',
      workspace: currentWorkspace
    })
  })
  .then(response => response.json())
  .then(data => {
    if (data.message) {
      currentPageName = data.message.name;
      document.getElementById('wb-title').value = data.message.title;
      document.getElementById('wb-crumb-title').textContent = data.message.title;
      
      // Add the new page to the UI
      addPageToUI(data.message);
      
      console.log('New empty page created:', data.message);
    }
  })
  .catch(error => {
    console.error('Error creating new page:', error);
  });
}

// Helper function to add page to UI
function addPageToUI(page) {
  const pagesContainer = document.querySelector('.wb-pages-list');
  if (!pagesContainer) return;
  
  // Remove empty state if it exists
  const emptyState = pagesContainer.querySelector('.wb-empty-pages');
  if (emptyState) {
    emptyState.remove();
  }
  
  // Create page item
  const pageItem = document.createElement('div');
  pageItem.className = 'wb-page-item active';
  pageItem.innerHTML = `
    <div class="wb-page-content">
      <div class="wb-page-icon">üìÑ</div>
      <div class="wb-page-info">
        <div class="wb-page-title">${page.title}</div>
        <div class="wb-page-meta">Just now</div>
      </div>
      <button class="wb-page-menu-btn" title="Page options">‚ãØ</button>
    </div>
  `;
  
  // Add click handler
  pageItem.querySelector('.wb-page-content').addEventListener('click', () => {
    loadPage(page.name);
  });
  
  // Add to container
  pagesContainer.appendChild(pageItem);
}

// Theme toggle and delete page functionality removed

// Notion-style block editor
function createNotionWorkbench() {
  console.log('Creating Notion-style workbench...');
  
  const editor = document.getElementById('wb-editor');
  if (!editor) {
    console.error('Editor element not found');
    return;
  }
  
  // Clear any existing content
  editor.innerHTML = '';
  
      // Block types
      const blockTypes = {
        paragraph: { icon: 'üìù', name: 'Text', create: () => createBlock('paragraph') },
        heading1: { icon: 'üìã', name: 'Heading 1', create: () => createBlock('heading1') },
        heading2: { icon: 'üìã', name: 'Heading 2', create: () => createBlock('heading2') },
        heading3: { icon: 'üìã', name: 'Heading 3', create: () => createBlock('heading3') },
        bulleted: { icon: '‚Ä¢', name: 'Bulleted list', create: () => createBlock('bulleted') },
        numbered: { icon: '1.', name: 'Numbered list', create: () => createBlock('numbered') },
        checklist: { icon: '‚òê', name: 'To-do list', create: () => createBlock('checklist') },
        toggle: { icon: 'üîΩ', name: 'Toggle', create: () => createBlock('toggle') },
        image: { icon: 'üñºÔ∏è', name: 'Image', create: () => createBlock('image') },
        file: { icon: 'üìé', name: 'File', create: () => createBlock('file') },
        code: { icon: 'üíª', name: 'Code', create: () => createBlock('code') },
        quote: { icon: 'üí¨', name: 'Quote', create: () => createBlock('quote') },
        divider: { icon: '‚ûñ', name: 'Divider', create: () => createBlock('divider') }
      };

      // Collection block types (only available when page is loaded)
      const collectionBlockTypes = {
        table: { icon: 'üìä', name: 'Table', create: () => createCollectionBlock('table') },
        board: { icon: 'üìã', name: 'Board', create: () => createCollectionBlock('board') },
        calendar: { icon: 'üìÖ', name: 'Calendar', create: () => createCollectionBlock('calendar') },
        gallery: { icon: 'üñºÔ∏è', name: 'Gallery', create: () => createCollectionBlock('gallery') },
        timeline: { icon: 'üìà', name: 'Timeline', create: () => createCollectionBlock('timeline') },
        list: { icon: 'üìù', name: 'List', create: () => createCollectionBlock('list') }
      };

      // Function to get all available block types
      function getAllBlockTypes() {
        // Always include collection blocks for testing
        return { ...blockTypes, ...collectionBlockTypes };
      }

      // Function to refresh slash menu when page changes
      function refreshSlashMenu() {
        // This will be called when a page is loaded to update available block types
        console.log('Page loaded, collection blocks now available');
      }
  
      // Get the position of a numbered list item in the sequence
      function getNumberedListPosition(currentBlock) {
        let position = 1;
        let current = currentBlock.previousElementSibling;
        
        // Count previous numbered items
        while (current) {
          if (current.dataset.type === 'numbered') {
            position++;
          } else if (current.dataset.type !== 'numbered') {
            // If we hit a non-numbered block, reset the sequence
            break;
          }
          current = current.previousElementSibling;
        }
        
        return position;
      }
      
      // Format file size
      function formatFileSize(bytes) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const sizes = ['Bytes', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }
      
      // Update all numbered list positions
      function updateNumberedListPositions() {
        const allBlocks = editor.querySelectorAll('.wb-block');
        let currentNumber = 1;
        
        allBlocks.forEach((block) => {
          if (block.dataset.type === 'numbered') {
            const numberSpan = block.querySelector('.wb-content > div > span');
            if (numberSpan) {
              numberSpan.textContent = currentNumber + '.';
              currentNumber++;
            }
          } else {
            // Reset numbering when we hit a non-numbered block
            currentNumber = 1;
          }
        });
      }
      
      // Create a collection block
      async function createCollectionBlock(viewType) {
        try {
          // If no current page, create a temporary one for demo purposes
          if (!currentPageName) {
            console.log('No current page, creating temporary page for collection block');
            // Create a temporary page name for demo
            currentPageName = `temp-page-${Date.now()}`;
            console.log('Using temporary page:', currentPageName);
          }
          
          const renderer = new CollectionBlockRenderer();
          const block = await renderer.createCollectionBlock(viewType, currentPageName);
          
          // Add save listener
          addSaveListener(block);
          
          return block;
        } catch (error) {
          console.error('Failed to create collection block:', error);
          // Fallback to paragraph block
          return createBlock('paragraph', '‚ùå Failed to create collection block. Please try again.');
        }
      }

      // Create a block
      function createBlock(type, content = '') {
    const block = document.createElement('div');
    block.className = 'wb-block';
    block.dataset.type = type;
    
    const blockId = 'block-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
    block.dataset.id = blockId;
    
        let contentHTML = '';
        switch(type) {
          case 'heading1':
            contentHTML = `<h1 contenteditable="true" class="wb-h1" style="font-size: 2em; font-weight: 700; margin: 0.67em 0; outline: none;">${content}</h1>`;
            break;
          case 'heading2':
            contentHTML = `<h2 contenteditable="true" class="wb-h2" style="font-size: 1.5em; font-weight: 700; margin: 0.75em 0; outline: none;">${content}</h2>`;
            break;
          case 'heading3':
            contentHTML = `<h3 contenteditable="true" class="wb-h3" style="font-size: 1.17em; font-weight: 700; margin: 0.83em 0; outline: none;">${content}</h3>`;
            break;
          case 'bulleted':
            contentHTML = `<ul style="margin: 0; padding-left: 1.5em;"><li contenteditable="true" style="outline: none; list-style-type: disc;">${content}</li></ul>`;
            break;
          case 'numbered':
            // Get the position of this numbered item in the sequence
            const numberedPosition = getNumberedListPosition(block);
            contentHTML = `<div style="display: flex; align-items: flex-start; gap: 8px; padding-left: 1.5em;"><span style="min-width: 20px; color: #666; user-select: none;">${numberedPosition}.</span><div contenteditable="true" style="outline: none; flex: 1;">${content}</div></div>`;
            break;
          case 'checklist':
            contentHTML = `<div style="display: flex; align-items: center; gap: 8px;"><input type="checkbox" style="margin: 0;"><span contenteditable="true" style="outline: none; flex: 1;">${content}</span></div>`;
            break;
          case 'toggle':
            contentHTML = `<div class="wb-toggle" data-open="true">
              <div class="wb-toggle-caret">‚ñº</div>
              <div class="wb-toggle-title" contenteditable="true" style="outline: none; flex: 1;">${content}</div>
            </div>`;
            break;
          case 'image':
            contentHTML = `<div class="wb-media wb-image-block" data-align="center" style="--w: 60%">
              <div class="wb-media-toolbar">
                <button class="wb-media-upload">Upload</button>
                <button class="wb-media-url">From URL</button>
              </div>
              <div class="wb-media-preview wb-media-empty">
                ${content.src ? `<img src="${content.src}" alt="${content.caption || ''}" style="width: 100%; border-radius: 8px;">` : 'Click Upload or From URL'}
              </div>
              <input class="wb-media-caption" placeholder="Add a caption..." value="${content.caption || ''}" style="outline: none; text-align: center; font-size: 14px; color: #666; margin-top: 8px;">
              <div class="wb-image-controls" style="display: none; position: absolute; top: 8px; right: 8px; background: rgba(0,0,0,0.7); border-radius: 4px; padding: 4px;">
                <button class="wb-image-align" data-align="left" title="Align Left">‚¨ÖÔ∏è</button>
                <button class="wb-image-align" data-align="center" title="Align Center">‚ÜîÔ∏è</button>
                <button class="wb-image-align" data-align="right" title="Align Right">‚û°Ô∏è</button>
                <button class="wb-image-resize" title="Resize">‚ÜîÔ∏è</button>
              </div>
            </div>`;
            break;
          case 'file':
            contentHTML = `<div class="wb-media wb-file-block">
              <div class="wb-media-toolbar">
                <button class="wb-media-upload">Upload</button>
                <button class="wb-media-url">From URL</button>
              </div>
              <div class="wb-media-preview wb-media-empty">
                ${content.url ? `<div class="wb-media-card"><span class="wb-media-icon">üìé</span><a href="${content.url}" target="_blank">${content.name || 'Untitled'}</a></div>` : 'No file yet'}
              </div>
            </div>`;
            break;
          case 'code':
            contentHTML = `<pre style="background: #f5f5f5; padding: 1em; border-radius: 4px; font-family: 'Courier New', monospace; margin: 0;"><code contenteditable="true" style="outline: none;">${content}</code></pre>`;
            break;
          case 'quote':
            contentHTML = `<blockquote contenteditable="true" style="border-left: 4px solid #ddd; padding-left: 1em; margin: 0; font-style: italic; color: #666; outline: none;">${content}</blockquote>`;
            break;
          case 'divider':
            contentHTML = `<hr style="border: none; border-top: 1px solid #ddd; margin: 1em 0;">`;
            break;
          default: // paragraph
            contentHTML = `<p contenteditable="true" style="margin: 0; outline: none;">${content}</p>`;
        }
    
        block.innerHTML = `
          <div class="wb-gutter" style="width: 32px; display: flex; gap: 6px; visibility: hidden; align-items: center;">
            <div class="wb-handle" style="width: 18px; height: 18px; border-radius: 6px; border: 1px solid #ddd; background: #fff; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: grab;" title="Drag to reorder">‚ãÆ</div>
            <div class="wb-plus" style="width: 18px; height: 18px; border-radius: 6px; border: 1px solid #ddd; background: #fff; display: flex; align-items: center; justify-content: center; font-size: 12px; cursor: pointer;" title="Add block">+</div>
          </div>
          <div class="wb-content" style="flex: 1; min-height: 1.5em;">
            ${contentHTML}
          </div>
        `;
    
        // Show gutter on hover
        block.addEventListener('mouseenter', () => {
          block.querySelector('.wb-gutter').style.visibility = 'visible';
        });
        block.addEventListener('mouseleave', () => {
          block.querySelector('.wb-gutter').style.visibility = 'hidden';
        });
        
        // Add event listeners for gutter buttons
        const plusBtn = block.querySelector('.wb-plus');
        const handleBtn = block.querySelector('.wb-handle');
        
        if (plusBtn) {
          plusBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showSlashMenu(block, block.querySelector('[contenteditable]'));
          });
        }
        
        if (handleBtn) {
          handleBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showBlockMenu(block);
          });
        }
        
        // Add specific event listeners for new block types
        if (type === 'toggle') {
          setupToggleEvents(block);
        } else if (type === 'image') {
          setupImageEvents(block);
        } else if (type === 'file') {
          setupFileEvents(block);
        }
    
    // Add event listeners
    setupBlockEvents(block);
    
    // Add save listener
    addSaveListener(block);
    
    return block;
  }
  
  // Setup block events
  function setupBlockEvents(block) {
    const editable = block.querySelector('[contenteditable="true"]');
    if (!editable) return;

    // Check if this block is inside a toggle
    const isInsideToggle = block.querySelector('.wb-toggle') || block.classList.contains('wb-toggle-child');
    
    editable.addEventListener('keydown', (e) => {
      
      // Handle Backspace key
      if (e.key === 'Backspace') {
        const isEmpty = editable.textContent.trim() === '';
        
        if (isEmpty) {
          // If inside a toggle and empty, exit the toggle by converting to paragraph
          if (block.classList.contains('wb-toggle-child')) {
            e.preventDefault();
            const newBlock = createBlock('paragraph', '');
            block.replaceWith(newBlock);
            const newEditable = newBlock.querySelector('[contenteditable="true"]');
            if (newEditable) {
              newEditable.focus();
            }
            return;
          }
          
          // Regular backspace behavior for non-toggle blocks
          const prevBlock = block.previousElementSibling;
          if (prevBlock && prevBlock.classList.contains('wb-block')) {
            e.preventDefault();
            const prevEditable = prevBlock.querySelector('[contenteditable="true"]');
            if (prevEditable) {
              prevEditable.focus();
              const range = document.createRange();
              range.selectNodeContents(prevEditable);
              range.collapse(false);
              const sel = window.getSelection();
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        }
      }
    });

    // Focus and typing
    editable.addEventListener('focus', () => {
      block.classList.add('focused');
    });
    
    editable.addEventListener('blur', () => {
      block.classList.remove('focused');
    });
    
    // Keyboard shortcuts
    editable.addEventListener('keydown', (e) => {
      // Slash command
      if (e.key === '/' && editable.textContent.trim() === '') {
        e.preventDefault();
        showSlashMenu(block, editable);
        return;
      }
      
      // Toggle block specific behavior
      if (block.dataset.type === 'toggle') {
        // ArrowLeft on caret at start: toggle open/closed
        if (e.key === 'ArrowLeft' && editable.selectionStart === 0) {
          const caret = block.querySelector('.wb-toggle-caret');
          if (caret) {
            e.preventDefault();
            toggleToggleBlock(block);
            return;
          }
        }
        
        // Enter in toggle: create indented child
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          
          const currentType = block.dataset.type;
          const currentText = editable.textContent.trim();
          
          // If it's a list type and has content, continue the list
          if ((currentType === 'bulleted' || currentType === 'numbered' || currentType === 'checklist') && currentText !== '') {
            const newBlock = createBlock(currentType);
            newBlock.style.marginLeft = '16px';
            newBlock.classList.add('wb-toggle-child');
            console.log('Toggle block list continuation: Created indented list item');
            block.insertAdjacentElement('afterend', newBlock);
            const newEditable = newBlock.querySelector('[contenteditable]');
            if (newEditable) {
              newEditable.focus();
            }
            // Update numbered list positions after adding new item
            if (currentType === 'numbered') {
              setTimeout(updateNumberedListPositions, 10);
            }
            return;
          }
          
          // Default: create paragraph
          const newBlock = createBlock('paragraph');
          newBlock.style.marginLeft = '16px';
          newBlock.classList.add('wb-toggle-child');
          console.log('Toggle block Enter: Created indented child block');
          block.insertAdjacentElement('afterend', newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          return;
        }
      }
      
      // Handle Enter key for blocks inside toggle (child blocks)
      if (e.key === 'Enter' && block.classList.contains('wb-toggle-child')) {
        e.preventDefault();
        
        const currentType = block.dataset.type;
        const currentText = editable.textContent.trim();
        
        // If it's a list type and has content, continue the list
        if ((currentType === 'bulleted' || currentType === 'numbered' || currentType === 'checklist') && currentText !== '') {
          const newBlock = createBlock(currentType);
          newBlock.style.marginLeft = '16px';
          newBlock.classList.add('wb-toggle-child');
          console.log('Toggle child block list continuation: Created indented list item');
          block.insertAdjacentElement('afterend', newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          // Update numbered list positions after adding new item
          if (currentType === 'numbered') {
            setTimeout(updateNumberedListPositions, 10);
          }
          return;
        }
        
        // Default: create paragraph
        const newBlock = createBlock('paragraph', '');
        newBlock.style.marginLeft = '16px';
        newBlock.classList.add('wb-toggle-child');
        console.log('Toggle child block Enter: Created indented child block');
        
        // Insert after current block
        block.parentNode.insertBefore(newBlock, block.nextSibling);
        
        // Focus the new block
        const newEditable = newBlock.querySelector('[contenteditable="true"]');
        newEditable.focus();
        return;
      }
  
      // Enter key - smart list continuation
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        
        const currentType = block.dataset.type;
        const currentText = editable.textContent.trim();
        
        // If current block is empty and it's a list item, convert to paragraph
        if (currentText === '' && (currentType === 'bulleted' || currentType === 'numbered' || currentType === 'checklist')) {
          const newBlock = createBlock('paragraph');
          
          // Check if we're inside a toggle (either as child or as toggle block itself)
          const isInsideToggle = block.classList.contains('wb-toggle-child') || block.querySelector('.wb-toggle');
          
          if (isInsideToggle) {
            newBlock.style.marginLeft = '16px';
            newBlock.classList.add('wb-toggle-child');
          }
          
          block.replaceWith(newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          // Update numbered list positions after converting
          if (currentType === 'numbered') {
            setTimeout(updateNumberedListPositions, 10);
          }
          return;
        }
        
        // If current block is a list type and has content, continue the list
        if ((currentType === 'bulleted' || currentType === 'numbered' || currentType === 'checklist') && currentText !== '') {
          const newBlock = createBlock(currentType);
          
          // Check if we're inside a toggle (either as child or as toggle block itself)
          const isInsideToggle = block.classList.contains('wb-toggle-child') || block.querySelector('.wb-toggle');
          
          console.log('List continuation debug:', {
            currentType,
            isInsideToggle,
            hasToggleChild: block.classList.contains('wb-toggle-child'),
            hasToggleElement: !!block.querySelector('.wb-toggle'),
            blockElement: block
          });
          
          if (isInsideToggle) {
            newBlock.style.marginLeft = '16px';
            newBlock.classList.add('wb-toggle-child');
            console.log('Created indented list item inside toggle');
          } else {
            console.log('Created regular list item outside toggle');
          }
          
          block.insertAdjacentElement('afterend', newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          // Update numbered list positions after adding new item
          if (currentType === 'numbered') {
            setTimeout(updateNumberedListPositions, 10);
          }
          return;
        }
        
        // Default: create paragraph block
        const newBlock = createBlock('paragraph');
        
        // Check if we're inside a toggle (either as child or as toggle block itself)
        const isInsideToggle = block.classList.contains('wb-toggle-child') || block.querySelector('.wb-toggle');
        
        if (isInsideToggle) {
          newBlock.style.marginLeft = '16px';
          newBlock.classList.add('wb-toggle-child');
        }
        
        block.insertAdjacentElement('afterend', newBlock);
        const newEditable = newBlock.querySelector('[contenteditable]');
        if (newEditable) {
          newEditable.focus();
        }
        return;
      }
  
      // Backspace on empty block
      if (e.key === 'Backspace' && editable.textContent.trim() === '') {
        e.preventDefault();
        const currentType = block.dataset.type;
        
        // If it's a list item (bulleted, numbered, checklist), convert to paragraph
        if (currentType === 'bulleted' || currentType === 'numbered' || currentType === 'checklist') {
          const newBlock = createBlock('paragraph');
          block.replaceWith(newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          // Update numbered list positions after converting
          if (currentType === 'numbered') {
            setTimeout(updateNumberedListPositions, 10);
          }
          return;
        }
        
        // For other block types, try to merge with previous block
        const prevBlock = block.previousElementSibling;
        if (prevBlock) {
          const prevEditable = prevBlock.querySelector('[contenteditable]');
          if (prevEditable) {
            prevEditable.focus();
            block.remove();
            // Update numbered list positions after removing item
            setTimeout(updateNumberedListPositions, 10);
          }
        }
        return;
      }
  
      // Rich text shortcuts
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 'b') {
          e.preventDefault();
          document.execCommand('bold');
        } else if (e.key === 'i') {
          e.preventDefault();
          document.execCommand('italic');
        } else if (e.key === 'u') {
          e.preventDefault();
          document.execCommand('underline');
        } else if (e.key === 'k') {
          e.preventDefault();
          if (e.shiftKey) {
            // Remove link
            removeLink(editable);
          } else {
            // Create link
            showLinkDialog(editable);
          }
        }
      }
    });
    
    // Click to focus
    editable.addEventListener('click', () => {
      editable.focus();
    });
  }
  
  // Slash menu
  function showSlashMenu(block, editable) {
    const menu = document.createElement('div');
    menu.className = 'wb-slash-menu';
    menu.style.cssText = `
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 280px;
      max-height: 300px;
      overflow-y: auto;
    `;
    
    Object.entries(getAllBlockTypes()).forEach(([key, type]) => {
      const item = document.createElement('div');
      item.className = 'wb-slash-item';
      item.style.cssText = `
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
      `;
      item.innerHTML = `
        <div style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 16px;">${type.icon}</div>
        <div style="flex: 1;">
          <div style="font-weight: 500; color: #333;">${type.name}</div>
        </div>
      `;
      
      item.addEventListener('click', async () => {
        try {
          const newBlock = await type.create();
          console.log('New block created:', newBlock);
          console.log('New block HTML:', newBlock.outerHTML);
          
          // Check if we're inside a toggle block
          const isInsideToggle = block.classList.contains('wb-toggle-child') || block.querySelector('.wb-toggle');
          
          if (isInsideToggle) {
            // If inside a toggle, create an indented child block
            newBlock.style.marginLeft = '16px';
            newBlock.classList.add('wb-toggle-child');
            block.insertAdjacentElement('afterend', newBlock);
            console.log('Block inserted after toggle');
          } else {
            // Regular replacement
            block.replaceWith(newBlock);
            console.log('Block replaced');
          }
          
          // Update numbered list positions if it's a numbered list
          if (newBlock.dataset.type === 'numbered') {
            setTimeout(updateNumberedListPositions, 10);
          }
          
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
          menu.remove();
        } catch (error) {
          console.error('Failed to create block:', error);
          menu.remove();
        }
      });
      
      menu.appendChild(item);
    });
    
    document.body.appendChild(menu);
    
    const rect = editable.getBoundingClientRect();
    menu.style.left = rect.left + 'px';
    menu.style.top = (rect.bottom + 5) + 'px';
    
    // Close menu when clicking outside
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 10);
  }
  
  // Block menu (3-dots menu)
  function showBlockMenu(block) {
    const menu = document.createElement('div');
    menu.className = 'wb-block-menu';
    menu.style.cssText = `
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 200px;
    `;
    
    const menuItems = [
      { icon: 'üìã', name: 'Duplicate', action: () => duplicateBlock(block) },
      { icon: 'üîó', name: 'Copy link', action: () => copyBlockLink(block) },
      { icon: 'üì§', name: 'Move to', action: () => moveBlock(block) },
      { icon: 'üóëÔ∏è', name: 'Delete', action: () => deleteBlock(block) }
    ];
    
    menuItems.forEach(item => {
      const menuItem = document.createElement('div');
      menuItem.className = 'wb-menu-item';
      menuItem.style.cssText = `
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
      `;
      menuItem.innerHTML = `
        <div style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 16px;">${item.icon}</div>
        <div style="flex: 1; color: #333;">${item.name}</div>
      `;
      
      menuItem.addEventListener('click', () => {
        item.action();
        menu.remove();
      });
      
      menu.appendChild(menuItem);
    });
    
    document.body.appendChild(menu);
    
    const rect = block.getBoundingClientRect();
    menu.style.left = (rect.left - 200) + 'px';
    menu.style.top = rect.top + 'px';
    
    // Close menu when clicking outside
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 10);
  }
  
  // Block actions
  function duplicateBlock(block) {
    const newBlock = createBlock(block.dataset.type, block.querySelector('[contenteditable]')?.textContent || '');
    block.insertAdjacentElement('afterend', newBlock);
    const newEditable = newBlock.querySelector('[contenteditable]');
    if (newEditable) {
      newEditable.focus();
    }
  }
  
  // Toggle block functionality
  function setupToggleEvents(block) {
    const caret = block.querySelector('.wb-toggle-caret');
    const title = block.querySelector('.wb-toggle-title');
    
    // Make the entire toggle clickable
    block.addEventListener('click', (e) => {
      if (e.target === title) return; // Don't toggle when clicking on text
      toggleToggleBlock(block);
    });
    
    if (caret) {
      caret.addEventListener('click', (e) => {
        e.stopPropagation();
        toggleToggleBlock(block);
      });
    }
    
    if (title) {
      title.addEventListener('click', (e) => {
        e.stopPropagation();
        title.focus();
      });
      
      // Enter handling is now in the main keydown event
    }
  }
  
  function toggleToggleBlock(block) {
    const isOpen = block.dataset.open === 'true';
    const caret = block.querySelector('.wb-toggle-caret');
    
    if (isOpen) {
      block.dataset.open = 'false';
      caret.textContent = '‚ñ∂';
      hideToggleChildren(block);
    } else {
      block.dataset.open = 'true';
      caret.textContent = '‚ñº';
      showToggleChildren(block);
    }
  }
  
  function hideToggleChildren(toggleBlock) {
    let current = toggleBlock.nextElementSibling;
    
    while (current) {
      // Check if the block is indented (has the ::before pseudo-element styling)
      const isIndented = current.style.marginLeft === '16px' || 
                       current.classList.contains('wb-toggle-child');
      
      if (!isIndented) {
        break; // Stop at non-indented blocks
      }
      
      current.style.display = 'none';
      current.classList.add('wb-toggle-hidden');
      current = current.nextElementSibling;
    }
  }
  
  function showToggleChildren(toggleBlock) {
    let current = toggleBlock.nextElementSibling;
    
    while (current) {
      // Check if the block is indented
      const isIndented = current.style.marginLeft === '16px' || 
                       current.classList.contains('wb-toggle-child');
      
      if (!isIndented) {
        break; // Stop at non-indented blocks
      }
      
      current.style.display = '';
      current.classList.remove('wb-toggle-hidden');
      current = current.nextElementSibling;
    }
  }
  
  function getBlockLevel(block) {
    // Check if block is indented under a toggle
    const isIndented = block.style.marginLeft === '16px' || 
                      block.classList.contains('wb-toggle-child');
    return isIndented ? 2 : 1;
  }
  
  // Image block functionality
  function setupImageEvents(block) {
    const uploadBtn = block.querySelector('.wb-media-upload');
    const urlBtn = block.querySelector('.wb-media-url');
    const preview = block.querySelector('.wb-media-preview');
    const caption = block.querySelector('.wb-media-caption');
    const controls = block.querySelector('.wb-image-controls');
    
    // Upload button
    if (uploadBtn) {
      uploadBtn.addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = 'image/*';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              // For now, create a local URL (in real implementation, upload to server)
              const localUrl = URL.createObjectURL(file);
              preview.classList.remove('wb-media-empty');
              preview.innerHTML = `<img src="${localUrl}" alt="" style="width: 100%; border-radius: 8px;">`;
              
              // Store file data
              block.dataset.media = JSON.stringify({
                type: 'image',
                file: {
                  name: file.name,
                  size: file.size,
                  type: file.type,
                  url: localUrl
                }
              });
              
              // Hide toolbar after upload
              hideMediaToolbar(block);
            } catch (error) {
              console.error('Image upload error:', error);
            }
          }
        };
        input.click();
      });
    }
    
    // URL button
    if (urlBtn) {
      urlBtn.addEventListener('click', () => {
        const url = prompt('Enter image URL:');
        if (url) {
          preview.classList.remove('wb-media-empty');
          preview.innerHTML = `<img src="${url}" alt="" style="width: 100%; border-radius: 8px;">`;
          block.dataset.media = JSON.stringify({
            type: 'image',
            url: url
          });
          hideMediaToolbar(block);
        }
      });
    }
    
    // Caption editing
    if (caption) {
      caption.addEventListener('input', () => {
        const data = JSON.parse(block.dataset.media || '{}');
        data.caption = caption.value;
        block.dataset.media = JSON.stringify(data);
      });
      
      caption.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
          e.preventDefault();
          const newBlock = createBlock('paragraph');
          block.insertAdjacentElement('afterend', newBlock);
          const newEditable = newBlock.querySelector('[contenteditable]');
          if (newEditable) {
            newEditable.focus();
          }
        }
      });
    }
    
    // Image controls for alignment and resize
    if (controls) {
      block.addEventListener('mouseenter', () => {
        controls.style.display = 'flex';
      });
      
      block.addEventListener('mouseleave', () => {
        controls.style.display = 'none';
      });
      
      // Alignment buttons
      const alignButtons = controls.querySelectorAll('.wb-image-align');
      alignButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const align = btn.dataset.align;
          block.dataset.align = align;
          updateImageAlignment(block, align);
        });
      });
      
      // Resize button
      const resizeBtn = controls.querySelector('.wb-image-resize');
      if (resizeBtn) {
        resizeBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          showImageResizeDialog(block);
        });
      }
    }
  }
  
  function updateImageAlignment(block, align) {
    const figure = block.querySelector('.wb-image');
    if (figure) {
      figure.style.textAlign = align;
      figure.style.marginLeft = align === 'left' ? '0' : 'auto';
      figure.style.marginRight = align === 'right' ? '0' : 'auto';
    }
  }
  
  function showImageResizeDialog(block) {
    const currentWidth = block.style.getPropertyValue('--w') || '60%';
    const width = prompt('Image width (percentage):', currentWidth.replace('%', ''));
    if (width && !isNaN(width) && width > 0 && width <= 100) {
      block.style.setProperty('--w', width + '%');
    }
  }
  
  // File block functionality
  function setupFileEvents(block) {
    const uploadBtn = block.querySelector('.wb-media-upload');
    const urlBtn = block.querySelector('.wb-media-url');
    const preview = block.querySelector('.wb-media-preview');
    
    const renderCard = (name, url) => {
      preview.classList.remove('wb-media-empty');
      preview.innerHTML = `<div class="wb-media-card"><span class="wb-media-icon">üìé</span><a href="${url}" target="_blank">${name}</a></div>`;
    };
    
    // Upload button
    if (uploadBtn) {
      uploadBtn.addEventListener('click', async () => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '*/*';
        input.onchange = async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              // For now, create a local URL (in real implementation, upload to server)
              const localUrl = URL.createObjectURL(file);
              renderCard(file.name, localUrl);
              
              // Store file data
              block.dataset.media = JSON.stringify({
                type: 'file',
                file: {
                  name: file.name,
                  size: file.size,
                  type: file.type,
                  url: localUrl
                }
              });
              
              // Hide toolbar after upload
              hideMediaToolbar(block);
            } catch (error) {
              console.error('File upload error:', error);
            }
          }
        };
        input.click();
      });
    }
    
    // URL button
    if (urlBtn) {
      urlBtn.addEventListener('click', () => {
        const url = prompt('Enter file URL:');
        if (url) {
          const name = url.split('/').pop() || 'file';
          renderCard(name, url);
          block.dataset.media = JSON.stringify({
            type: 'file',
            url: url,
            name: name
          });
          hideMediaToolbar(block);
        }
      });
    }
  }
  
  function showFileUploadDialog(block) {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.pdf,.doc,.docx,.txt,.jpg,.jpeg,.png,.gif,.mp4,.mp3,.zip,.rar';
    input.addEventListener('change', (e) => {
      if (e.target.files.length > 0) {
        handleFileUpload(block, e.target.files[0]);
      }
    });
    input.click();
  }
  
  function hideMediaToolbar(block) {
    const toolbar = block.querySelector('.wb-media-toolbar');
    if (toolbar) {
      toolbar.style.display = 'none';
    }
  }
  
  function showMediaToolbar(block) {
    const toolbar = block.querySelector('.wb-media-toolbar');
    if (toolbar) {
      toolbar.style.display = 'flex';
    }
  }
  
  // Link dialog functionality
  function showLinkDialog(editable) {
    const selection = window.getSelection();
    const selectedText = selection.toString().trim();
    
    const dialog = document.createElement('div');
    dialog.className = 'wb-link-dialog';
    dialog.style.cssText = `
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      padding: 12px;
      z-index: 1000;
      min-width: 300px;
    `;
    
    dialog.innerHTML = `
      <div style="margin-bottom: 8px;">
        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 4px;">Text:</label>
        <input type="text" id="link-text" value="${selectedText}" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
      </div>
      <div style="margin-bottom: 12px;">
        <label style="display: block; font-size: 12px; color: #666; margin-bottom: 4px;">URL:</label>
        <input type="url" id="link-url" placeholder="https://example.com" style="width: 100%; padding: 6px; border: 1px solid #ddd; border-radius: 4px;">
      </div>
      <div style="display: flex; gap: 8px; justify-content: flex-end;">
        <button id="link-cancel" style="padding: 6px 12px; border: 1px solid #ddd; background: white; border-radius: 4px; cursor: pointer;">Cancel</button>
        <button id="link-apply" style="padding: 6px 12px; border: none; background: #2383e2; color: white; border-radius: 4px; cursor: pointer;">Apply</button>
      </div>
    `;
    
    document.body.appendChild(dialog);
    
    // Position dialog
    const rect = editable.getBoundingClientRect();
    dialog.style.left = rect.left + 'px';
    dialog.style.top = (rect.bottom + 5) + 'px';
    
    // Focus URL input
    const urlInput = dialog.querySelector('#link-url');
    urlInput.focus();
    
    // Event listeners
    dialog.querySelector('#link-cancel').addEventListener('click', () => {
      dialog.remove();
    });
    
    dialog.querySelector('#link-apply').addEventListener('click', () => {
      const text = dialog.querySelector('#link-text').value.trim();
      const url = dialog.querySelector('#link-url').value.trim();
      
      if (text && url && isValidUrl(url)) {
        createLink(editable, text, url);
        dialog.remove();
      } else {
        alert('Please enter valid text and URL');
      }
    });
    
    // Close on escape
    const handleEscape = (e) => {
      if (e.key === 'Escape') {
        dialog.remove();
        document.removeEventListener('keydown', handleEscape);
      }
    };
    document.addEventListener('keydown', handleEscape);
    
    // Close on outside click
    const handleOutsideClick = (e) => {
      if (!dialog.contains(e.target)) {
        dialog.remove();
        document.removeEventListener('click', handleOutsideClick);
      }
    };
    setTimeout(() => document.addEventListener('click', handleOutsideClick), 10);
  }
  
  function createLink(editable, text, url) {
    // If text is selected, replace it with link
    if (window.getSelection().toString().trim()) {
      document.execCommand('createLink', false, url);
    } else {
      // Insert link at cursor
      const link = `<a href="${url}" target="_blank" rel="noopener noreferrer">${text}</a>`;
      document.execCommand('insertHTML', false, link);
    }
  }
  
  function removeLink(editable) {
    // Check if cursor is inside a link
    const selection = window.getSelection();
    if (selection.rangeCount > 0) {
      const range = selection.getRangeAt(0);
      const link = range.commonAncestorContainer.closest ? 
        range.commonAncestorContainer.closest('a') : 
        range.commonAncestorContainer.parentElement?.closest('a');
      
      if (link) {
        // Unwrap the link
        const parent = link.parentNode;
        while (link.firstChild) {
          parent.insertBefore(link.firstChild, link);
        }
        parent.removeChild(link);
      }
    }
  }
  
  function isValidUrl(string) {
    try {
      const url = new URL(string);
      return url.protocol === 'http:' || url.protocol === 'https:';
    } catch (_) {
      return false;
    }
  }
  
  function copyBlockLink(block) {
    const blockId = block.dataset.id;
    const link = `${window.location.origin}${window.location.pathname}#${blockId}`;
    navigator.clipboard.writeText(link);
    console.log('Block link copied:', link);
  }
  
  function moveBlock(block) {
    // TODO: Implement move to different page/workspace
    console.log('Move block:', block.dataset.id);
  }
  
  function deleteBlock(block) {
    if (confirm('Delete this block?')) {
      block.remove();
      if (block.dataset.type === 'numbered') {
        setTimeout(updateNumberedListPositions, 10);
      }
    }
  }
  
  // Save functionality
  let saveTimeout = null;
  
  function saveContent() {
    if (!currentPageName) return;
    
    const blocks = [];
    editor.querySelectorAll('.wb-block').forEach(block => {
      const type = block.dataset.type;
      const editable = block.querySelector('[contenteditable]');
      let content = '';
      
      if (editable) {
        content = editable.textContent || '';
      }
      
      const blockData = {
        id: block.dataset.id,
        type: type,
        content: content
      };
      
      // Add collection-specific metadata
      if (type === 'collection' && block.collectionData) {
        blockData.blockId = block.collectionData.blockId;
        blockData.viewType = block.collectionData.viewType;
      }
      
      blocks.push(blockData);
    });
    
    const contentData = {
      blocks: blocks,
      timestamp: new Date().toISOString()
    };
    
    // Get CSRF token from Frappe's global variable
    const csrfToken = window.csrf_token || 
                     (window.frappe && window.frappe.csrf_token) ||
                     document.querySelector('meta[name="csrf-token"]')?.getAttribute('content');
    
    console.log('Using CSRF token:', csrfToken);
    
    // Save to backend
    console.log('Content would be saved:', {
      name: currentPageName,
      content: contentData
    });
    
    fetch('/api/method/workbench.api.update_page', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      },
      body: JSON.stringify({
        name: currentPageName,
        content_json: JSON.stringify(contentData)
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        console.log('Content saved successfully');
      } else {
        console.error('Save failed:', data);
      }
    })
    .catch(error => {
      console.error('Save error:', error);
    });
  }
  
  function debouncedSave() {
    if (saveTimeout) {
      clearTimeout(saveTimeout);
    }
    saveTimeout = setTimeout(saveContent, 2000); // Save after 2 seconds of inactivity
  }
  
  // Create a new page
  function createNewPage(title = 'New Page', workspace = null) {
    const csrfToken = window.csrf_token || 
                     (window.frappe && window.frappe.csrf_token);
    
    const targetWorkspace = workspace || currentWorkspace;
    if (!targetWorkspace) {
      console.error('No workspace selected for page creation');
      return;
    }
    
    fetch('/api/method/workbench.api.create_page', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      },
      body: JSON.stringify({
        workspace: targetWorkspace,
        title: title,
        content_json: null,
        visibility: 'Use Workspace',
        company: null,
        collaborators: null
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        currentPageName = data.message.name;
        document.getElementById('wb-title').value = data.message.title;
        console.log('New page created:', data.message);
        refreshSlashMenu();
        
        // Reload pages list
        if (currentWorkspace) {
          loadPages();
        }
        
        // Refresh workspace pages if created in a workspace
        if (targetWorkspace) {
          refreshWorkspacePages(targetWorkspace);
        }
      } else {
        console.error('Page creation failed:', data);
      }
    })
    .catch(error => {
      console.error('Page creation error:', error);
    });
  }
  
  // Add save trigger to all content changes
  function addSaveListener(block) {
    const editable = block.querySelector('[contenteditable]');
    if (editable) {
      editable.addEventListener('input', debouncedSave);
      editable.addEventListener('blur', debouncedSave);
    }
  }
  
  // Workspace and page management (variables are now global)
  
  // Initialize workspace and page management
  initializeWorkspaceManagement();
  
  // Workspace management functions
  function initializeWorkspaceManagement() {
    loadWorkspaces();
    setupWorkspaceEventListeners();
  }
  
  function loadWorkspaces() {
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch('/api/method/workbench.api.get_user_workspaces', {
      method: 'GET',
      headers: {
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        populateWorkspaceList(data.message);
        if (data.message.length > 0 && !currentWorkspace) {
          currentWorkspace = data.message[0].name;
          loadPages();
        }
      }
    })
    .catch(error => {
      console.error('Error loading workspaces:', error);
    });
  }
  
  function populateWorkspaceList(workspaces) {
    const workspaceList = document.getElementById('wb-workspaces');
    workspaceList.innerHTML = '';
    
    workspaces.forEach(workspace => {
      const workspaceItem = document.createElement('div');
      workspaceItem.className = 'wb-workspace-item';
      workspaceItem.dataset.workspaceName = workspace.name;
      workspaceItem.innerHTML = `
        <div class="wb-workspace-header">
          <span class="wb-workspace-icon">üè†</span>
          <span class="wb-workspace-text">${workspace.title}</span>
          <div class="wb-workspace-actions">
            <span class="wb-workspace-toggle">‚ñº</span>
            <button class="wb-workspace-menu-btn" title="Workspace options">‚ãØ</button>
          </div>
        </div>
        <div class="wb-workspace-pages" style="display: none;">
          <div class="wb-workspace-new-page">
            <span class="wb-workspace-new-icon">+</span>
            <span class="wb-workspace-new-text">New page</span>
          </div>
          <div class="wb-workspace-page-list"></div>
        </div>
      `;
      
      // Toggle workspace expansion
      const toggle = workspaceItem.querySelector('.wb-workspace-toggle');
      const pagesContainer = workspaceItem.querySelector('.wb-workspace-pages');
      const menuBtn = workspaceItem.querySelector('.wb-workspace-menu-btn');
      
      // Handle workspace header click (excluding menu button)
      workspaceItem.querySelector('.wb-workspace-header').addEventListener('click', (e) => {
        // Don't toggle if clicking the menu button
        if (e.target.closest('.wb-workspace-menu-btn')) {
          return;
        }
        
        const isExpanded = pagesContainer.style.display !== 'none';
        pagesContainer.style.display = isExpanded ? 'none' : 'block';
        toggle.textContent = isExpanded ? '‚ñ∂' : '‚ñº';
        
        // Load pages when expanding
        if (!isExpanded) {
          currentWorkspace = workspace.name;
          loadWorkspacePages(workspace.name, pagesContainer.querySelector('.wb-workspace-page-list'));
        }
      });
      
      // Handle workspace menu button click
      menuBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showWorkspaceMenu(workspace, workspaceItem);
      });
      
      // New page in workspace
      const newPageItem = workspaceItem.querySelector('.wb-workspace-new-page');
      newPageItem.addEventListener('click', (e) => {
        e.stopPropagation();
        const title = prompt('Page name:', 'New Page');
        if (title) {
          createNewPage(title, workspace.name);
        }
      });
      
      workspaceList.appendChild(workspaceItem);
    });
  }
  
  function setupWorkspaceEventListeners() {
    const newWorkspaceBtn = document.getElementById('wb-new-workspace');
    const newPageBtn = document.getElementById('wb-new-page');
    const newPageItem = document.querySelector('.wb-new-page-item');
    const addWorkspaceItem = document.querySelector('.wb-add-workspace-item');
    
    if (newWorkspaceBtn) {
      newWorkspaceBtn.addEventListener('click', () => {
        const title = prompt('Workspace name:', 'New Workspace');
        if (title) {
          createNewWorkspace(title);
        }
      });
    }
    
    if (addWorkspaceItem) {
      addWorkspaceItem.addEventListener('click', () => {
        const title = prompt('Workspace name:', 'New Workspace');
        if (title) {
          createNewWorkspace(title);
        }
      });
    }
    
    if (newPageBtn) {
      newPageBtn.addEventListener('click', () => {
        const title = prompt('Page name:', 'New Page');
        if (title) {
          createNewPage(title, currentWorkspace);
        }
      });
    }
    
    if (newPageItem) {
      newPageItem.addEventListener('click', () => {
        const title = prompt('Page name:', 'New Page');
        if (title) {
          createNewPage(title, currentWorkspace);
        }
      });
    }
  }
  
  function createNewWorkspace(title) {
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch('/api/method/workbench.api.create_workspace', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      },
      body: JSON.stringify({
        title: title,
        description: '',
        visibility: 'Private',
        company: null,
        collaborators: null
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        console.log('New workspace created:', data.message);
        loadWorkspaces(); // This will refresh the workspace list
        currentWorkspace = data.message;
      } else {
        console.error('Workspace creation failed:', data);
      }
    })
    .catch(error => {
      console.error('Workspace creation error:', error);
    });
  }
  
  function loadPages() {
    if (!currentWorkspace) {
      console.log('No current workspace, cannot load pages');
      return;
    }
    
    console.log('Loading pages for workspace:', currentWorkspace);
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch(`/api/method/workbench.api.get_workspace_pages?workspace=${currentWorkspace}`, {
      method: 'GET',
      headers: {
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      }
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        console.log('Pages loaded:', data.message);
        populatePageList(data.message);
      } else {
        console.log('No pages data received');
      }
    })
    .catch(error => {
      console.error('Error loading pages:', error);
    });
  }
  
  function loadWorkspacePages(workspaceName, container) {
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch('/api/method/workbench.api.get_workspace_pages', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      },
      body: JSON.stringify({
        workspace: workspaceName
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.message) {
        populateWorkspacePageList(data.message, container);
      }
    })
    .catch(error => {
      console.error('Error loading workspace pages:', error);
    });
  }
  
  function refreshWorkspacePages(workspaceName) {
    const workspaceItem = document.querySelector(`[data-workspace-name="${workspaceName}"]`);
    if (workspaceItem) {
      const pagesContainer = workspaceItem.querySelector('.wb-workspace-page-list');
      if (pagesContainer) {
        loadWorkspacePages(workspaceName, pagesContainer);
      }
    }
  }
  
  function populatePageList(pages) {
    console.log('populatePageList called with pages:', pages);
    
    // Update private pages section
    const privatePageList = document.getElementById('wb-private-pages');
    if (privatePageList) {
      console.log('Updating private pages list');
      privatePageList.innerHTML = '';
      pages.forEach(page => {
        const pageItem = createPageItem(page);
        privatePageList.appendChild(pageItem);
      });
    } else {
      console.log('Private pages list not found');
    }
    
    // Also refresh the current workspace if it's expanded
    refreshCurrentWorkspace();
  }
  
  function refreshCurrentWorkspace() {
    if (!currentWorkspace) {
      console.log('No current workspace to refresh');
      return;
    }
    
    console.log('Refreshing current workspace:', currentWorkspace);
    
    // Find the current workspace element - try different selectors
    let workspaceElement = document.querySelector(`[data-workspace-name="${currentWorkspace}"]`);
    if (!workspaceElement) {
      // Try finding by workspace name in the text content
      const workspaceItems = document.querySelectorAll('.wb-workspace-item');
      for (let item of workspaceItems) {
        const workspaceText = item.querySelector('.wb-workspace-text');
        if (workspaceText && workspaceText.textContent.includes(currentWorkspace)) {
          workspaceElement = item;
          break;
        }
      }
    }
    
    if (!workspaceElement) {
      console.log('Workspace element not found for:', currentWorkspace);
      return;
    }
    
    // Find the pages container within this workspace - try different selectors
    let pagesContainer = workspaceElement.querySelector('.wb-workspace-page-list');
    if (!pagesContainer) {
      pagesContainer = workspaceElement.querySelector('.wb-pages-list');
    }
    if (!pagesContainer) {
      pagesContainer = workspaceElement.querySelector('.wb-page-list');
    }
    if (!pagesContainer) {
      console.log('Pages container not found in workspace, trying to create one');
      // Create a pages container if it doesn't exist
      const workspacePages = workspaceElement.querySelector('.wb-workspace-pages');
      if (workspacePages) {
        pagesContainer = document.createElement('div');
        pagesContainer.className = 'wb-workspace-page-list';
        workspacePages.appendChild(pagesContainer);
      }
    }
    
    if (!pagesContainer) {
      console.log('Could not find or create pages container');
      return;
    }
    
    console.log('Reloading pages for workspace:', currentWorkspace);
    // Reload pages for this specific workspace
    loadWorkspacePages(currentWorkspace, pagesContainer);
  }
  
  function populateWorkspacePageList(pages, container) {
    container.innerHTML = '';
    
    pages.forEach(page => {
      const pageItem = createPageItem(page);
      container.appendChild(pageItem);
    });
  }
  
  function createPageItem(page) {
    const pageItem = document.createElement('div');
    pageItem.className = 'wb-page-item';
    pageItem.innerHTML = `
      <div class="wb-page-content">
        <div class="wb-page-title">${page.title}</div>
        <div class="wb-page-meta">${new Date(page.modified).toLocaleDateString()}</div>
      </div>
      <div class="wb-page-actions">
        <button class="wb-page-menu-btn" title="Page options">‚ãÆ</button>
      </div>
    `;
    
    // Click to load page
    pageItem.querySelector('.wb-page-content').addEventListener('click', () => {
      loadPage(page.name);
    });
    
    // Right-click or menu button for page options
    const menuBtn = pageItem.querySelector('.wb-page-menu-btn');
    menuBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      showPageMenu(page, pageItem);
    });
    
    pageItem.addEventListener('contextmenu', (e) => {
      e.preventDefault();
      showPageMenu(page, pageItem);
    });
    
    return pageItem;
  }
  
  function loadPage(pageName) {
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch(`/api/method/workbench.api.get_page?name=${pageName}`, {
      method: 'GET',
      headers: {
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      }
    })
    .then(response => {
      if (response.status === 404) {
        console.log('Page not found (likely deleted):', pageName);
        // Clear current page if it was deleted
        if (currentPageName === pageName) {
          currentPageName = null;
          document.getElementById('wb-editor').innerHTML = '';
          document.getElementById('wb-title').value = '';
          document.getElementById('wb-crumb-title').textContent = 'New page';
        }
        return;
      }
      return response.json();
    })
    .then(data => {
      if (data && data.message) {
        currentPageName = data.message.name;
        document.getElementById('wb-title').value = data.message.title;
        refreshSlashMenu();
        
        // Load content
        if (data.message.content_json) {
          try {
            const content = JSON.parse(data.message.content_json);
            loadPageContent(content);
          } catch (e) {
            console.error('Error parsing page content:', e);
          }
        }
      }
    })
    .catch(error => {
      console.error('Error loading page:', error);
    });
  }
  
  function loadPageContent(content) {
    const editor = document.getElementById('wb-editor');
    editor.innerHTML = '';
    
    if (content.blocks) {
      content.blocks.forEach(async (blockData) => {
        if (blockData.type === 'collection') {
          // Handle collection blocks specially
          const renderer = new CollectionBlockRenderer();
          const block = await renderer.loadCollectionBlock(blockData.blockId, blockData.viewType, currentPageName);
          block.dataset.id = blockData.id;
          editor.appendChild(block);
          addSaveListener(block);
        } else {
          // Handle regular blocks
          const block = createBlock(blockData.type, blockData.content || '');
          block.dataset.id = blockData.id;
          editor.appendChild(block);
          addSaveListener(block);
        }
      });
    }
    
    // Focus first block
    const firstBlock = editor.querySelector('.wb-block');
    if (firstBlock) {
      const editable = firstBlock.querySelector('[contenteditable]');
      if (editable) {
        setTimeout(() => editable.focus(), 100);
      }
    }
  }
  
  // Workspace menu functionality
  function showWorkspaceMenu(workspace, workspaceItem) {
    const menu = document.createElement('div');
    menu.className = 'wb-workspace-menu';
    menu.style.cssText = `
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 200px;
    `;
    
    const menuItems = [
      { icon: '‚úèÔ∏è', name: 'Rename workspace', action: () => renameWorkspace(workspace) },
      { icon: 'üóëÔ∏è', name: 'Delete workspace & all pages', action: () => deleteWorkspace(workspace) }
    ];
    
    menuItems.forEach(item => {
      const menuItem = document.createElement('div');
      menuItem.className = 'wb-workspace-menu-item';
      menuItem.innerHTML = `
        <span class="wb-workspace-menu-icon">${item.icon}</span>
        <span class="wb-workspace-menu-text">${item.name}</span>
      `;
      menuItem.addEventListener('click', () => {
        item.action();
        menu.remove();
      });
      menu.appendChild(menuItem);
    });
    
    // Position menu
    const rect = workspaceItem.getBoundingClientRect();
    menu.style.left = `${rect.right - 200}px`;
    menu.style.top = `${rect.top + 30}px`;
    
    document.body.appendChild(menu);
    
    // Close menu when clicking outside
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    
    setTimeout(() => {
      document.addEventListener('click', closeMenu);
    }, 100);
  }
  
  // Rename workspace
  function renameWorkspace(workspace) {
    const newTitle = prompt('Rename workspace:', workspace.title);
    if (newTitle && newTitle.trim() && newTitle !== workspace.title) {
      const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
      
      fetch('/api/method/workbench.api.update_workspace_settings', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Frappe-CSRF-Token': csrfToken || 'token'
        },
        body: JSON.stringify({
          workspace_name: workspace.name,
          title: newTitle.trim()
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.message && data.message.ok) {
          console.log('Workspace renamed successfully');
          loadWorkspaces(); // Refresh workspace list
        } else {
          console.error('Rename failed:', data.message?.error || data);
          alert('Failed to rename workspace: ' + (data.message?.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Rename error:', error);
        alert('Error renaming workspace: ' + error.message);
      });
    }
  }
  
  // Delete workspace
  function deleteWorkspace(workspace) {
    if (confirm(`Delete workspace "${workspace.title}" and all pages inside it? This action cannot be undone.`)) {
      const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
      
      // First, get ALL pages in the workspace (including private/archived ones)
      fetch('/api/method/workbench.api.get_all_workspace_pages', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Frappe-CSRF-Token': csrfToken || 'token'
        },
        body: JSON.stringify({
          workspace: workspace.name
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.message) {
          const pages = data.message;
          console.log(`Found ${pages.length} pages in workspace, deleting them first...`);
          
          // Delete all pages first (with collections)
          const deletePromises = pages.map(page => {
            console.log(`Deleting page: ${page.name}`);
            
            // First, delete all collections for this page
            return fetch('/api/method/workbench.workbench.inline_api.inline_collection.delete_page_collections', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Frappe-CSRF-Token': csrfToken || 'token'
              },
              body: JSON.stringify({
                page: page.name
              })
            }).then(response => response.json())
            .then(collectionResult => {
              console.log(`Collections deleted for page ${page.name}:`, collectionResult);
              
              // Then delete the page
              return fetch('/api/method/workbench.api.delete_page', {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-Frappe-CSRF-Token': csrfToken || 'token'
                },
                body: JSON.stringify({
                  name: page.name,
                  hard: 1 // Hard delete
                })
              }).then(response => response.json())
              .then(data => {
                console.log(`Page ${page.name} delete result:`, data);
                return data;
              });
            });
          });
          
          // Wait for all pages to be deleted
          return Promise.all(deletePromises);
        } else {
          return []; // No pages to delete
        }
      })
      .then(() => {
        console.log('All pages deleted, verifying workspace is empty...');
        
        // Add a small delay to ensure database is updated
        return new Promise(resolve => setTimeout(resolve, 1000));
      })
      .then(() => {
        // Verify workspace is empty before deleting
        return fetch(`/api/method/workbench.api.get_workspace_pages?workspace=${workspace.name}`, {
          method: 'GET',
          headers: {
            'X-Frappe-CSRF-Token': csrfToken || 'token'
          }
        });
      })
      .then(response => response.json())
      .then(data => {
        console.log('Verification result:', data);
        if (data.message && data.message.length > 0) {
          console.error(`Workspace still has ${data.message.length} pages, cannot delete`);
          throw new Error(`Workspace still has ${data.message.length} pages`);
        }
        console.log('Workspace is empty, proceeding with deletion...');
        
        // Let's also check what the delete_workspace API sees
        console.log('About to call delete_workspace API with workspace_name:', workspace.name);
        
        // Now delete the workspace
        return fetch('/api/method/workbench.api.delete_workspace', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Frappe-CSRF-Token': csrfToken || 'token'
          },
          body: JSON.stringify({
            workspace_name: workspace.name
          })
        });
      })
      .then(response => response.json())
      .then(data => {
        if (data.message && data.message.ok) {
          console.log('Workspace and all pages deleted successfully');
          loadWorkspaces(); // Refresh workspace list
        } else {
          console.error('Delete failed:', data.message?.error || data);
          alert('Failed to delete workspace: ' + (data.message?.error || 'Unknown error'));
        }
      })
      .catch(error => {
        console.error('Delete error:', error);
        alert('Error deleting workspace: ' + error.message);
      });
    }
  }

  // Page menu functionality
  function showPageMenu(page, pageItem) {
    const menu = document.createElement('div');
    menu.className = 'wb-page-menu';
    menu.style.cssText = `
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.15);
      z-index: 1000;
      min-width: 200px;
    `;
    
    const menuItems = [
      { icon: 'üì§', name: 'Move to workspace', action: () => showMoveToWorkspaceDialog(page) },
      { icon: 'üìã', name: 'Duplicate', action: () => duplicatePage(page) },
      { icon: 'üóëÔ∏è', name: 'Delete', action: () => deletePage(page) }
    ];
    
    menuItems.forEach(item => {
      const menuItem = document.createElement('div');
      menuItem.className = 'wb-menu-item';
      menuItem.style.cssText = `
        display: flex;
        align-items: center;
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid #f0f0f0;
      `;
      menuItem.innerHTML = `
        <div style="width: 24px; height: 24px; display: flex; align-items: center; justify-content: center; margin-right: 12px; font-size: 16px;">${item.icon}</div>
        <div style="flex: 1; color: #333;">${item.name}</div>
      `;
      
      menuItem.addEventListener('click', () => {
        item.action();
        menu.remove();
      });
      
      menu.appendChild(menuItem);
    });
    
    document.body.appendChild(menu);
    
    const rect = pageItem.getBoundingClientRect();
    menu.style.left = (rect.right - 200) + 'px';
    menu.style.top = rect.top + 'px';
    
    // Close menu when clicking outside
    const closeMenu = (e) => {
      if (!menu.contains(e.target)) {
        menu.remove();
        document.removeEventListener('click', closeMenu);
      }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 10);
  }
  
  // Move page to workspace dialog
  function showMoveToWorkspaceDialog(page) {
    // Get workspaces from the workspace list
    const workspaceItems = document.querySelectorAll('.wb-workspace-item');
    const workspaces = Array.from(workspaceItems).map(item => {
      const textElement = item.querySelector('.wb-workspace-text');
      return {
        name: item.dataset.workspaceName || textElement.textContent,
        title: textElement.textContent
      };
    });
    
    if (workspaces.length <= 1) {
      alert('No other workspaces available to move to.');
      return;
    }
    
    const workspaceNames = workspaces.map(ws => ws.title).join('\n');
    const targetWorkspace = prompt(`Move "${page.title}" to which workspace?\n\nAvailable workspaces:\n${workspaceNames}`);
    
    if (targetWorkspace) {
      const targetWs = workspaces.find(ws => ws.title === targetWorkspace);
      if (targetWs) {
        movePageToWorkspace(page.name, targetWs.name);
      } else {
        alert('Invalid workspace selected.');
      }
    }
  }
  
  // Move page to workspace
  function movePageToWorkspace(pageName, workspaceName) {
    const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
    
    fetch('/api/method/workbench.api.move_page_to_workspace', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-Frappe-CSRF-Token': csrfToken || 'token'
      },
      body: JSON.stringify({
        page_name: pageName,
        workspace_name: workspaceName
      })
    })
    .then(response => response.json())
    .then(data => {
      if (data.message && data.message.ok) {
        console.log('Page moved successfully');
        loadPages(); // Reload pages list
      } else {
        console.error('Move failed:', data.message?.error || data);
        alert('Failed to move page: ' + (data.message?.error || 'Unknown error'));
      }
    })
    .catch(error => {
      console.error('Move error:', error);
      alert('Error moving page: ' + error.message);
    });
  }
  
  // Duplicate page
  function duplicatePage(page) {
    const newTitle = prompt('New page title:', page.title + ' Copy');
    if (newTitle) {
      createNewPage(newTitle, currentWorkspace);
    }
  }
  
  // Delete page
  function deletePage(page) {
    if (confirm(`Delete "${page.title}"? This action cannot be undone.`)) {
      const csrfToken = window.csrf_token || (window.frappe && window.frappe.csrf_token);
      
      // Add a small delay to avoid database lock issues
      setTimeout(() => {
        // First delete all collections for this page
        fetch('/api/method/workbench.workbench.inline_api.inline_collection.delete_page_collections', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Frappe-CSRF-Token': csrfToken || 'token'
          },
          body: JSON.stringify({
            page: page.name
          })
        })
        .then(response => response.json())
        .then(data => {
          console.log('Collections deleted for page:', data);
          
          // Add another small delay before deleting the page
          setTimeout(() => {
            // Then delete the page
            fetch('/api/method/workbench.api.delete_page', {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'X-Frappe-CSRF-Token': csrfToken || 'token'
              },
              body: JSON.stringify({
                name: page.name,
                hard: 1 // Hard delete
              })
            })
            .then(response => response.json())
            .then(data => {
              if (data.message && data.message.ok) {
                console.log('Page deleted successfully');
                
                // Clear editor if this was the current page
                if (currentPageName === page.name) {
                  document.getElementById('wb-editor').innerHTML = '';
                  document.getElementById('wb-title').value = '';
                  document.getElementById('wb-crumb-title').textContent = 'New page';
                  currentPageName = null;
                }
                
                // Reload pages list
                loadPages();
                
                // Also refresh current workspace
                refreshCurrentWorkspace();
              } else {
                console.error('Delete failed:', data);
                alert('Failed to delete page');
              }
            })
            .catch(error => {
              console.error('Delete error:', error);
              alert('Error deleting page: ' + error.message);
            });
          }, 500);
        })
        .catch(error => {
          console.error('Collections delete error:', error);
          alert('Error deleting collections: ' + error.message);
        });
      }, 100);
    }
  }
  
  // Create initial block
  const initialBlock = createBlock('paragraph', 'Type "/" for commands or start typing...');
  editor.appendChild(initialBlock);
  addSaveListener(initialBlock);
  
  // Focus the initial block
  setTimeout(() => {
    const editable = initialBlock.querySelector('[contenteditable]');
    if (editable) {
      editable.focus();
    }
  }, 100);
  
  // Add click handler to editor to create new blocks
  editor.addEventListener('click', (e) => {
    // Only handle clicks on the editor container itself, not on blocks
    if (e.target === editor) {
      const newBlock = createBlock('paragraph', '');
      editor.appendChild(newBlock);
      addSaveListener(newBlock);
      
      // Focus the new block
      setTimeout(() => {
        const editable = newBlock.querySelector('[contenteditable]');
        if (editable) {
          editable.focus();
        }
      }, 10);
    }
  });
  
  // Add event listeners for UI elements
  const newPageBtn = document.getElementById('wb-new-page');
  const titleInput = document.getElementById('wb-title');
  
  if (newPageBtn) {
    newPageBtn.addEventListener('click', () => {
      createNewPage('New Page');
    });
  }
  
  if (titleInput) {
    titleInput.addEventListener('blur', () => {
      const newTitle = titleInput.value.trim() || 'Untitled';
      if (currentPageName && newTitle !== titleInput.value) {
        // Update page title
        const csrfToken = window.csrf_token || 
                         (window.frappe && window.frappe.csrf_token);
        
        fetch('/api/method/workbench.api.update_page', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Frappe-CSRF-Token': csrfToken || 'token'
          },
          body: JSON.stringify({
            name: currentPageName,
            title: newTitle
          })
        })
        .then(response => response.json())
        .then(data => {
          if (data.message) {
            console.log('Page title updated');
          } else {
            console.error('Title update failed:', data);
          }
        })
        .catch(error => {
          console.error('Title update error:', error);
        });
      }
    });
  }
  
  // Theme and delete functionality removed
  
  console.log('Notion-style workbench with save functionality created successfully');
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  console.log('DOM loaded, creating Notion-style workbench...');
  
  // Debug CSRF token availability
  console.log('Available CSRF tokens:');
  console.log('window.csrf_token:', window.csrf_token);
  console.log('window.frappe?.csrf_token:', window.frappe?.csrf_token);
  console.log('document.querySelector meta:', document.querySelector('meta[name="csrf-token"]')?.getAttribute('content'));
  
  createNotionWorkbench();
});
</script>

<style>
/* Main Layout Styles */
#wb-app {
  display: flex;
  height: 100vh;
  overflow: hidden;
}

.wb-main {
  flex: 1;
  display: flex;
  flex-direction: column;
  height: 100vh;
  overflow: hidden;
}

.wb-page-header {
  flex-shrink: 0;
  padding: 16px 24px;
  border-bottom: 1px solid #e1e5e9;
  background: white;
}

.wb-page-title-row {
  flex-shrink: 0;
  padding: 0 24px 16px 24px;
  background: white;
}

.wb-title {
  width: 100%;
  border: none;
  outline: none;
  font-size: 32px;
  font-weight: 700;
  color: #333;
  background: transparent;
  padding: 0;
  margin: 0;
}

.wb-title::placeholder {
  color: #999;
}

#wb-editor {
  flex: 1;
  padding: 0 24px 200px 24px;
  overflow-y: auto;
  overflow-x: hidden;
  min-height: 0;
  background: white;
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}

#wb-editor::-webkit-scrollbar {
  width: 8px;
}

#wb-editor::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

#wb-editor::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

#wb-editor::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Workspace Menu Styles */
.wb-workspace-actions {
  display: flex;
  align-items: center;
  gap: 8px;
}

.wb-workspace-menu-btn {
  background: none;
  border: none;
  padding: 4px;
  border-radius: 4px;
  cursor: pointer;
  color: #666;
  font-size: 16px;
  line-height: 1;
  opacity: 0;
  transition: opacity 0.2s, background-color 0.2s;
}

.wb-workspace-item:hover .wb-workspace-menu-btn {
  opacity: 1;
}

.wb-workspace-menu-btn:hover {
  background-color: #f0f0f0;
  color: #333;
}

.wb-workspace-menu {
  position: absolute;
  background: white;
  border: 1px solid #ddd;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0,0,0,0.15);
  z-index: 1000;
  min-width: 200px;
  overflow: hidden;
}

.wb-workspace-menu-item {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px 16px;
  cursor: pointer;
  transition: background-color 0.2s;
  border-bottom: 1px solid #f0f0f0;
}

.wb-workspace-menu-item:last-child {
  border-bottom: none;
}

.wb-workspace-menu-item:hover {
  background-color: #f8f9fa;
}

.wb-workspace-menu-icon {
  font-size: 16px;
  width: 20px;
  text-align: center;
}

.wb-workspace-menu-text {
  font-size: 14px;
  color: #333;
}

/* Collection Block Styles */
.wb-collection-block {
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  background: white;
  margin: 8px 0;
  overflow: visible;
  min-height: 400px;
  width: 100%;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  display: flex;
  flex-direction: column;
}

.wb-collection-header {
  background: #f8f9fa;
  border-bottom: 1px solid #e1e5e9;
  padding: 8px 12px;
}

.wb-collection-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
}

.wb-collection-toolbar-left,
.wb-collection-toolbar-right {
  display: flex;
  align-items: center;
  gap: 4px;
}

.wb-collection-toolbar-center {
  flex: 1;
  display: flex;
  justify-content: center;
}

.wb-collection-view-switcher {
  display: flex;
  background: white;
  border: 1px solid #d1d5db;
  border-radius: 6px;
  overflow: hidden;
}

.wb-collection-view-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  border: none;
  background: transparent;
  cursor: pointer;
  font-size: 12px;
  color: #6b7280;
  transition: all 0.2s;
}

.wb-collection-view-btn:hover {
  background: #f3f4f6;
  color: #374151;
}

.wb-collection-view-btn.active {
  background: #3b82f6;
  color: white;
}

.wb-collection-view-btn .wb-icon {
  font-size: 14px;
}

.wb-collection-view-btn .wb-label {
  font-weight: 500;
}

.wb-collection-new-btn {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  background: #3b82f6;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  font-weight: 500;
  transition: background 0.2s;
}

.wb-collection-new-btn:hover {
  background: #2563eb;
}

.wb-collection-filter-btn,
.wb-collection-sort-btn,
.wb-collection-search-btn,
.wb-collection-more-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border: 1px solid #d1d5db;
  background: white;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.2s;
}

.wb-collection-filter-btn:hover,
.wb-collection-sort-btn:hover,
.wb-collection-search-btn:hover,
.wb-collection-more-btn:hover {
  background: #f3f4f6;
  border-color: #9ca3af;
}

.wb-collection-content {
  padding: 16px;
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 0;
  overflow-y: auto;
  max-height: 600px;
}

.wb-collection-view-container {
  min-height: 300px;
  padding: 20px;
  background: #fafafa;
  border-radius: 6px;
  flex: 1;
  display: flex;
  flex-direction: column;
  overflow: auto;
}

/* Table View Styles */
.wb-table-view {
  width: 100%;
  background: white;
  border-radius: 6px;
  overflow: hidden;
  flex: 1;
  display: flex;
  flex-direction: column;
  min-height: 200px;
}

.wb-table {
  width: 100%;
  border-collapse: collapse;
  font-size: 14px;
  background: white;
  border-radius: 6px;
  overflow: hidden;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
  flex: 1;
  min-height: 200px;
}

.wb-table th {
  text-align: left;
  padding: 8px 12px;
  background: #f8f9fa;
  border-bottom: 1px solid #e1e5e9;
  font-weight: 600;
  color: #374151;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.wb-table td {
  padding: 12px;
  border-bottom: 1px solid #f3f4f6;
  vertical-align: top;
  background: white;
}

.wb-table tr:hover {
  background: #f8f9fa;
}

.wb-table tbody {
  display: block;
  max-height: 400px;
  overflow-y: auto;
}

.wb-table thead,
.wb-table tbody tr {
  display: table;
  width: 100%;
  table-layout: fixed;
}

.wb-table-actions {
  text-align: right;
  white-space: nowrap;
}

.wb-item-edit-btn,
.wb-item-delete-btn {
  padding: 4px 8px;
  margin-left: 4px;
  border: 1px solid #d1d5db;
  background: white;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  transition: all 0.2s;
}

.wb-item-edit-btn:hover {
  background: #f3f4f6;
  border-color: #9ca3af;
}

.wb-item-delete-btn:hover {
  background: #fef2f2;
  border-color: #fca5a5;
  color: #dc2626;
}

.wb-table-empty {
  text-align: center;
}

.wb-empty-state {
  padding: 40px 20px;
  color: #6b7280;
  text-align: center;
  flex: 1;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  min-height: 200px;
}

.wb-empty-icon {
  font-size: 48px;
  margin-bottom: 16px;
  opacity: 0.5;
}

.wb-empty-text {
  font-size: 16px;
  font-weight: 500;
  margin-bottom: 8px;
  color: #374151;
}

.wb-empty-subtext {
  font-size: 14px;
  color: #6b7280;
}

/* Property Chips */
.wb-property-chip {
  display: inline-block;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
  margin-right: 4px;
  margin-bottom: 2px;
}

.wb-property-select {
  background: #dbeafe;
  color: #1e40af;
}

.wb-property-multi-select {
  background: #f3f4f6;
  color: #374151;
}

.wb-property-file {
  color: #6b7280;
  font-size: 12px;
}

/* Responsive Design */
@media (max-width: 768px) {
  .wb-collection-block {
    margin: 4px 0;
    min-height: 300px;
  }
  
  .wb-collection-toolbar {
    flex-wrap: wrap;
    gap: 8px;
    padding: 8px;
  }
  
  .wb-collection-view-switcher {
    order: 3;
    width: 100%;
    justify-content: center;
    margin: 8px 0;
  }
  
  .wb-collection-view-btn {
    padding: 4px 8px;
    font-size: 12px;
  }
  
  .wb-collection-view-btn .wb-label {
    display: none;
  }
  
  .wb-collection-content {
    padding: 12px;
  }
  
  .wb-collection-view-container {
    padding: 12px;
    min-height: 200px;
  }
  
  .wb-table {
    font-size: 12px;
  }
  
  .wb-table th,
  .wb-table td {
    padding: 6px 8px;
  }
  
  .wb-collection-new-btn {
    padding: 6px 12px;
    font-size: 12px;
  }
}

@media (max-width: 480px) {
  .wb-collection-block {
    margin: 2px 0;
    min-height: 250px;
  }
  
  .wb-collection-toolbar {
    flex-direction: column;
    gap: 4px;
  }
  
  .wb-collection-toolbar-left,
  .wb-collection-toolbar-right {
    justify-content: center;
    width: 100%;
  }
  
  .wb-collection-view-switcher {
    order: 0;
    margin: 0 0 8px 0;
  }
  
  .wb-collection-content {
    padding: 8px;
  }
  
  .wb-collection-view-container {
    padding: 8px;
    min-height: 150px;
  }
}

/* Board View Styles */
.wb-board-view {
  padding: 16px;
  overflow-y: auto;
  max-height: 100%;
}

.wb-board-columns {
  display: flex;
  gap: 16px;
  overflow-x: auto;
  padding-bottom: 16px;
  min-height: 0;
  flex: 1;
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}

.wb-board-columns::-webkit-scrollbar {
  height: 8px;
}

.wb-board-columns::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

.wb-board-columns::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

.wb-board-columns::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

.wb-board-column {
  min-width: 280px;
  background: #f8f9fa;
  border-radius: 8px;
  padding: 16px;
}

.wb-board-column-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 12px;
  padding-bottom: 8px;
  border-bottom: 1px solid #e1e5e9;
}

.wb-board-column-header h3 {
  margin: 0;
  font-size: 14px;
  font-weight: 600;
  color: #333;
}

.wb-board-count {
  background: #e3f2fd;
  color: #1976d2;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 500;
}

.wb-board-card {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 6px;
  padding: 12px;
  margin-bottom: 8px;
  cursor: pointer;
  transition: all 0.2s ease;
}

.wb-board-card:hover {
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  border-color: #1976d2;
}

.wb-board-card-title {
  font-weight: 500;
  margin-bottom: 4px;
  color: #333;
}

.wb-board-card-meta {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
}

.wb-board-card-actions {
  display: flex;
  gap: 4px;
}

.wb-board-card-actions button {
  padding: 4px 8px;
  font-size: 11px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

/* Calendar View Styles */
.wb-calendar-view {
  padding: 16px;
  overflow-y: auto;
  max-height: 100%;
}

.wb-calendar-header {
  margin-bottom: 16px;
  text-align: center;
}

.wb-calendar-header h3 {
  margin: 0;
  font-size: 18px;
  font-weight: 600;
  color: #333;
}

.wb-calendar-grid {
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  overflow: hidden;
}

.wb-calendar-weekdays {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
  background: #f8f9fa;
  border-bottom: 1px solid #e1e5e9;
}

.wb-calendar-weekdays > div {
  padding: 8px;
  text-align: center;
  font-weight: 600;
  font-size: 12px;
  color: #666;
}

.wb-calendar-days {
  display: grid;
  grid-template-columns: repeat(7, 1fr);
}

.wb-calendar-day {
  min-height: 80px;
  border-right: 1px solid #e1e5e9;
  border-bottom: 1px solid #e1e5e9;
  padding: 8px;
  position: relative;
}

.wb-calendar-day:last-child {
  border-right: none;
}

.wb-calendar-day-empty {
  background: #f8f9fa;
}

.wb-calendar-day-today {
  background: #e3f2fd;
}

.wb-calendar-day-number {
  font-weight: 600;
  margin-bottom: 4px;
  color: #333;
}

.wb-calendar-item {
  background: #1976d2;
  color: white;
  padding: 4px 6px;
  border-radius: 4px;
  font-size: 11px;
  margin-bottom: 2px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
}

.wb-calendar-item-start {
  border-left: 3px solid #0d47a1;
}

.wb-calendar-item-end {
  border-right: 3px solid #0d47a1;
}

.wb-calendar-item-spanning {
  background: #e3f2fd;
  color: #1976d2;
  border: 1px solid #1976d2;
}

.wb-calendar-item-title {
  font-weight: 500;
  margin-bottom: 2px;
}

.wb-calendar-item-assignee {
  font-size: 10px;
  opacity: 0.9;
  margin-bottom: 1px;
}

.wb-calendar-item-priority {
  font-size: 9px;
  padding: 1px 4px;
  border-radius: 2px;
  font-weight: 500;
}

.priority-low { background: #4caf50; color: white; }
.priority-medium { background: #ff9800; color: white; }
.priority-high { background: #f44336; color: white; }
.priority-urgent { background: #9c27b0; color: white; }

/* Gallery View Styles */
.wb-gallery-view {
  padding: 16px;
  overflow-y: auto;
  max-height: 100%;
}

.wb-gallery-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 16px;
}

.wb-gallery-item {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.2s ease;
}

.wb-gallery-item:hover {
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  border-color: #1976d2;
}

.wb-gallery-item-image {
  height: 120px;
  background: #f8f9fa;
  display: flex;
  align-items: center;
  justify-content: center;
}

.wb-gallery-placeholder {
  font-size: 32px;
  color: #ccc;
}

.wb-gallery-item-content {
  padding: 12px;
}

.wb-gallery-item-title {
  font-weight: 500;
  margin-bottom: 4px;
  color: #333;
}

.wb-gallery-item-meta {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
  display: flex;
  gap: 8px;
}

.wb-gallery-item-actions {
  display: flex;
  gap: 4px;
}

.wb-gallery-item-actions button {
  padding: 4px 8px;
  font-size: 11px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

/* Timeline View Styles */
.wb-timeline-view {
  padding: 16px;
  overflow-y: auto;
  max-height: 100%;
}

.wb-timeline-container {
  position: relative;
  padding-left: 24px;
}

.wb-timeline-container::before {
  content: '';
  position: absolute;
  left: 12px;
  top: 0;
  bottom: 0;
  width: 2px;
  background: #e1e5e9;
}

.wb-timeline-item {
  position: relative;
  margin-bottom: 24px;
}

.wb-timeline-marker {
  position: absolute;
  left: -18px;
  top: 8px;
  width: 12px;
  height: 12px;
  background: #1976d2;
  border-radius: 50%;
  border: 3px solid white;
  box-shadow: 0 0 0 2px #e1e5e9;
}

.wb-timeline-content {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  padding: 16px;
  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
}

.wb-timeline-item-title {
  font-weight: 600;
  margin-bottom: 4px;
  color: #333;
}

.wb-timeline-item-meta {
  font-size: 12px;
  color: #666;
  margin-bottom: 8px;
  display: flex;
  gap: 12px;
}

.wb-timeline-item-actions {
  display: flex;
  gap: 4px;
}

.wb-timeline-item-actions button {
  padding: 4px 8px;
  font-size: 11px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

.wb-timeline-item-range {
  position: relative;
}

.wb-timeline-item-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.wb-timeline-priority {
  font-size: 10px;
  padding: 2px 6px;
  border-radius: 3px;
  font-weight: 500;
}

.wb-timeline-item-status {
  font-size: 11px;
  padding: 2px 6px;
  border-radius: 3px;
  font-weight: 500;
}

.status-not-started { background: #e0e0e0; color: #666; }
.status-in-progress { background: #e3f2fd; color: #1976d2; }
.status-done { background: #e8f5e8; color: #2e7d32; }

.wb-timeline-item-assignee {
  font-size: 11px;
  color: #666;
  margin-left: 8px;
}

.wb-timeline-item-bar {
  height: 4px;
  background: linear-gradient(90deg, #1976d2, #42a5f5);
  border-radius: 2px;
  margin: 8px 0;
  position: relative;
}

.wb-timeline-item-bar::before {
  content: '';
  position: absolute;
  left: 0;
  top: 0;
  height: 100%;
  background: repeating-linear-gradient(
    90deg,
    transparent,
    transparent 4px,
    rgba(255,255,255,0.3) 4px,
    rgba(255,255,255,0.3) 8px
  );
  width: 100%;
}

.wb-timeline-marker.priority-low { background: #4caf50; }
.wb-timeline-marker.priority-medium { background: #ff9800; }
.wb-timeline-marker.priority-high { background: #f44336; }
.wb-timeline-marker.priority-urgent { background: #9c27b0; }

/* List View Styles */
.wb-list-view {
  padding: 16px;
  overflow-y: auto;
  max-height: 100%;
}

.wb-list-container {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  overflow: hidden;
}

.wb-list-item {
  display: flex;
  align-items: center;
  padding: 12px 16px;
  border-bottom: 1px solid #f0f0f0;
  transition: background-color 0.2s ease;
}

.wb-list-item:last-child {
  border-bottom: none;
}

.wb-list-item:hover {
  background: #f8f9fa;
}

.wb-list-item-content {
  flex: 1;
}

.wb-list-item-title {
  font-weight: 500;
  margin-bottom: 2px;
  color: #333;
}

.wb-list-item-meta {
  font-size: 12px;
  color: #666;
  display: flex;
  gap: 12px;
}

.wb-list-item-actions {
  display: flex;
  gap: 4px;
}

.wb-list-item-actions button {
  padding: 4px 8px;
  font-size: 11px;
  border: 1px solid #ddd;
  background: white;
  border-radius: 4px;
  cursor: pointer;
}

/* Custom Scrollbar Styles */
.wb-collection-content::-webkit-scrollbar,
.wb-board-view::-webkit-scrollbar,
.wb-calendar-view::-webkit-scrollbar,
.wb-gallery-view::-webkit-scrollbar,
.wb-timeline-view::-webkit-scrollbar,
.wb-list-view::-webkit-scrollbar {
  width: 8px;
}

.wb-collection-content::-webkit-scrollbar-track,
.wb-board-view::-webkit-scrollbar-track,
.wb-calendar-view::-webkit-scrollbar-track,
.wb-gallery-view::-webkit-scrollbar-track,
.wb-timeline-view::-webkit-scrollbar-track,
.wb-list-view::-webkit-scrollbar-track {
  background: #f1f5f9;
  border-radius: 4px;
}

.wb-collection-content::-webkit-scrollbar-thumb,
.wb-board-view::-webkit-scrollbar-thumb,
.wb-calendar-view::-webkit-scrollbar-thumb,
.wb-gallery-view::-webkit-scrollbar-thumb,
.wb-timeline-view::-webkit-scrollbar-thumb,
.wb-list-view::-webkit-scrollbar-thumb {
  background: #cbd5e1;
  border-radius: 4px;
}

.wb-collection-content::-webkit-scrollbar-thumb:hover,
.wb-board-view::-webkit-scrollbar-thumb:hover,
.wb-calendar-view::-webkit-scrollbar-thumb:hover,
.wb-gallery-view::-webkit-scrollbar-thumb:hover,
.wb-timeline-view::-webkit-scrollbar-thumb:hover,
.wb-list-view::-webkit-scrollbar-thumb:hover {
  background: #94a3b8;
}

/* Firefox scrollbar styles */
.wb-collection-content,
.wb-board-view,
.wb-calendar-view,
.wb-gallery-view,
.wb-timeline-view,
.wb-list-view {
  scrollbar-width: thin;
  scrollbar-color: #cbd5e1 #f1f5f9;
}

/* Dark theme styles */
[data-theme="dark"] {
  --wb-bg: #1a1a1a;
  --wb-sidebar-bg: #2d2d2d;
  --wb-text: #e0e0e0;
  --wb-text-muted: #a0a0a0;
  --wb-border: #404040;
  --wb-hover: #3a3a3a;
  --wb-active: #4a4a4a;
  --wb-shadow: rgba(0, 0, 0, 0.3);
  --wb-input-bg: #2d2d2d;
  --wb-button-bg: #404040;
  --wb-button-hover: #505050;
  --wb-danger: #ff6b6b;
  --wb-danger-hover: #ff5252;
}

[data-theme="dark"] #wb-app {
  background: var(--wb-bg);
  color: var(--wb-text);
}

[data-theme="dark"] .wb-sidebar {
  background: var(--wb-sidebar-bg);
  border-right-color: var(--wb-border);
}

[data-theme="dark"] .wb-page-header {
  background: var(--wb-bg);
  border-bottom-color: var(--wb-border);
}

[data-theme="dark"] .wb-page-title-row {
  background: var(--wb-bg);
}

[data-theme="dark"] .wb-title {
  color: var(--wb-text);
  background: transparent;
}

[data-theme="dark"] .wb-editor {
  background: var(--wb-bg);
  color: var(--wb-text);
}

[data-theme="dark"] .wb-block {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-block[contenteditable="true"] {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-block[contenteditable="true"]:focus {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-workspace-header {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-workspace-header:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-page-item {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-page-item:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-page-item.active {
  background: var(--wb-active);
}

[data-theme="dark"] .wb-btn {
  background: var(--wb-button-bg);
  color: var(--wb-text);
  border-color: var(--wb-border);
}

[data-theme="dark"] .wb-btn:hover {
  background: var(--wb-button-hover);
}

[data-theme="dark"] .wb-btn.danger {
  background: var(--wb-danger);
  color: white;
}

[data-theme="dark"] .wb-btn.danger:hover {
  background: var(--wb-danger-hover);
}

[data-theme="dark"] .wb-btn.ghost {
  background: transparent;
  color: var(--wb-text);
}

[data-theme="dark"] .wb-btn.ghost:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-search input {
  background: var(--wb-input-bg);
  color: var(--wb-text);
  border-color: var(--wb-border);
}

[data-theme="dark"] .wb-search input::placeholder {
  color: var(--wb-text-muted);
}

[data-theme="dark"] .wb-badge {
  background: var(--wb-button-bg);
  color: var(--wb-text);
}

[data-theme="dark"] .wb-slash-menu {
  background: var(--wb-sidebar-bg);
  border-color: var(--wb-border);
  box-shadow: 0 4px 12px var(--wb-shadow);
}

[data-theme="dark"] .wb-slash-menu-item {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-slash-menu-item:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-block-menu {
  background: var(--wb-sidebar-bg);
  border-color: var(--wb-border);
  box-shadow: 0 4px 12px var(--wb-shadow);
}

[data-theme="dark"] .wb-block-menu-item {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-block-menu-item:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-collection-block {
  background: var(--wb-bg);
  border-color: var(--wb-border);
}

[data-theme="dark"] .wb-collection-header {
  background: var(--wb-sidebar-bg);
  border-bottom-color: var(--wb-border);
}

[data-theme="dark"] .wb-collection-view-btn {
  color: var(--wb-text);
}

[data-theme="dark"] .wb-collection-view-btn:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-collection-view-btn.active {
  background: var(--wb-active);
}

[data-theme="dark"] .wb-table {
  background: var(--wb-bg);
  color: var(--wb-text);
}

[data-theme="dark"] .wb-table th {
  background: var(--wb-sidebar-bg);
  color: var(--wb-text);
  border-color: var(--wb-border);
}

[data-theme="dark"] .wb-table td {
  border-color: var(--wb-border);
}

[data-theme="dark"] .wb-table tr:hover {
  background: var(--wb-hover);
}

[data-theme="dark"] .wb-empty-state {
  color: var(--wb-text-muted);
}

[data-theme="dark"] .wb-modal {
  background: var(--wb-sidebar-bg);
  color: var(--wb-text);
}

[data-theme="dark"] .wb-modal-header {
  background: var(--wb-bg);
  border-bottom-color: var(--wb-border);
}

[data-theme="dark"] .wb-modal-content {
  background: var(--wb-bg);
}

[data-theme="dark"] .wb-modal-footer {
  background: var(--wb-bg);
  border-top-color: var(--wb-border);
}
</style>
{% endblock %}
